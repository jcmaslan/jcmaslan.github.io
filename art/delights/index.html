<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perlin Landscape Journey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            background-color: #0a0a0a;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let timeRef = 0;
        let walkCycle = 0;
        let blossoms = [];
        let mistClouds = [];
        let plants = [];
        
        // Resize canvas to fill window
        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Perlin noise implementation
        const perlin = (() => {
            const permutation = [];
            for (let i = 0; i < 256; i++) permutation[i] = i;
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
            }
            const p = [...permutation, ...permutation];
            
            const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
            const lerp = (t, a, b) => a + t * (b - a);
            const grad = (hash, x, y) => {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            };
            
            return (x, y) => {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = fade(x);
                const v = fade(y);
                const a = p[X] + Y;
                const aa = p[a];
                const ab = p[a + 1];
                const b = p[X + 1] + Y;
                const ba = p[b];
                const bb = p[b + 1];
                
                return lerp(v,
                    lerp(u, grad(p[aa], x, y), grad(p[ba], x - 1, y)),
                    lerp(u, grad(p[ab], x, y - 1), grad(p[bb], x - 1, y - 1))
                );
            };
        })();
        
        // Multi-octave Perlin noise
        const noise = (x, y, octaves = 4) => {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;
            
            for (let i = 0; i < octaves; i++) {
                value += perlin(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return value / maxValue;
        };
        
        // Helper function to interpolate between two hex colors
        function interpolateColor(color1, color2, t) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);
            
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        
        // Create blossom
        const createBlossom = () => ({
            x: Math.random() * width,
            y: Math.random() * height * 0.8 + height * 0.1,
            age: 0,
            maxAge: 100 + Math.random() * 100,
            petals: 5 + Math.floor(Math.random() * 8),
            size: 15 + Math.random() * 35,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.02,
            hue: Math.random() * 60 + 300,
            layers: 2 + Math.floor(Math.random() * 3)
        });
        
        // Create mist cloud
        const createMistCloud = () => ({
            x: -100,
            y: Math.random() * height * 0.5,
            speed: 0.3 + Math.random() * 0.8,
            particles: Array.from({ length: 40 + Math.floor(Math.random() * 60) }, () => ({
                offsetX: Math.random() * 200 - 100,
                offsetY: Math.random() * 60 - 30,
                size: 1 + Math.random() * 3,
                opacity: 0.1 + Math.random() * 0.4,
                twinkle: Math.random() * Math.PI * 2,
                twinkleSpeed: 0.02 + Math.random() * 0.04,
                isSparkling: Math.random() < 0.25
            })),
            width: 150 + Math.random() * 100,
            hue: 200 + Math.random() * 80
        });
        
        // Create plant
        const createPlant = () => ({
            x: width + 10,
            y: height,
            age: 0,
            maxAge: 180,
            height: 8 + Math.random() * 12,
            branches: 2 + Math.floor(Math.random() * 3),
            hue: 80 + Math.random() * 60,
            speed: 1.2 + Math.random() * 0.4
        });
        
        // Initialize
        for (let i = 0; i < 5; i++) {
            blossoms.push(createBlossom());
        }
        
        for (let i = 0; i < 2; i++) {
            const cloud = createMistCloud();
            cloud.x = Math.random() * width;
            mistClouds.push(cloud);
        }
        
        // Draw blossom
        const drawBlossom = (blossom) => {
            const progress = blossom.age / blossom.maxAge;
            const fade = progress < 0.2 ? progress / 0.2 : progress > 0.8 ? (1 - progress) / 0.2 : 1;
            const scale = Math.sin(progress * Math.PI) * fade;
            
            if (scale <= 0) return;
            
            ctx.save();
            ctx.translate(blossom.x, blossom.y);
            ctx.rotate(blossom.rotation);
            ctx.scale(scale, scale);
            
            for (let layer = 0; layer < blossom.layers; layer++) {
                const layerSize = 1 - (layer * 0.3);
                const layerPetals = blossom.petals + layer;
                
                for (let i = 0; i < layerPetals; i++) {
                    const angle = (Math.PI * 2 * i) / layerPetals + layer * 0.3;
                    
                    ctx.save();
                    ctx.rotate(angle);
                    
                    ctx.beginPath();
                    
                    const petalLength = blossom.size * layerSize;
                    const petalWidth = petalLength * 0.4;
                    
                    ctx.moveTo(0, 0);
                    ctx.bezierCurveTo(
                        petalWidth * 0.5, petalLength * 0.3,
                        petalWidth * 0.5, petalLength * 0.7,
                        0, petalLength
                    );
                    ctx.bezierCurveTo(
                        -petalWidth * 0.5, petalLength * 0.7,
                        -petalWidth * 0.5, petalLength * 0.3,
                        0, 0
                    );
                    
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, petalLength);
                    const alpha = fade * 0.7;
                    gradient.addColorStop(0, `hsla(${blossom.hue + layer * 10}, 80%, 70%, ${alpha})`);
                    gradient.addColorStop(0.5, `hsla(${blossom.hue + layer * 10}, 70%, 60%, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `hsla(${blossom.hue + layer * 10}, 60%, 50%, ${alpha * 0.3})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = `hsla(${blossom.hue}, 60%, 40%, ${alpha * 0.3})`;
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, petalLength);
                    ctx.stroke();
                    
                    for (let j = 1; j <= 3; j++) {
                        ctx.beginPath();
                        ctx.moveTo(0, petalLength * j * 0.25);
                        ctx.quadraticCurveTo(
                            petalWidth * 0.3, petalLength * j * 0.25,
                            petalWidth * 0.4, petalLength * (j * 0.25 + 0.1)
                        );
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, petalLength * j * 0.25);
                        ctx.quadraticCurveTo(
                            -petalWidth * 0.3, petalLength * j * 0.25,
                            -petalWidth * 0.4, petalLength * (j * 0.25 + 0.1)
                        );
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            }
            
            const centerSize = blossom.size * 0.2 * scale;
            const centerGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, centerSize);
            centerGradient.addColorStop(0, `hsla(${blossom.hue + 40}, 90%, 80%, ${fade})`);
            centerGradient.addColorStop(1, `hsla(${blossom.hue + 20}, 80%, 60%, ${fade * 0.8})`);
            ctx.fillStyle = centerGradient;
            ctx.beginPath();
            ctx.arc(0, 0, centerSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = `hsla(${blossom.hue + 60}, 100%, 90%, ${fade * 0.9})`;
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                const x = Math.cos(angle) * centerSize * 0.6;
                const y = Math.sin(angle) * centerSize * 0.6;
                ctx.beginPath();
                ctx.arc(x, y, centerSize * 0.15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        };
        
        // Draw mist cloud
        const drawMistCloud = (cloud) => {
            cloud.particles.forEach(particle => {
                const x = cloud.x + particle.offsetX;
                const y = cloud.y + particle.offsetY;
                
                particle.twinkle += particle.twinkleSpeed;
                const twinkle = Math.sin(particle.twinkle) * 0.3 + 0.7;
                
                if (particle.isSparkling) {
                    const sparkleIntensity = Math.sin(particle.twinkle) * 0.5 + 0.5;
                    const opacity = (0.6 + sparkleIntensity * 0.4) * twinkle;
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, particle.size * 3);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                    gradient.addColorStop(0.3, `rgba(255, 255, 240, ${opacity * 0.8})`);
                    gradient.addColorStop(0.6, `rgba(230, 240, 255, ${opacity * 0.4})`);
                    gradient.addColorStop(1, `rgba(200, 220, 255, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, particle.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (sparkleIntensity > 0.7) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${(sparkleIntensity - 0.7) * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    const opacity = particle.opacity * twinkle;
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, particle.size * 2);
                    gradient.addColorStop(0, `hsla(${cloud.hue}, 70%, 80%, ${opacity})`);
                    gradient.addColorStop(0.5, `hsla(${cloud.hue}, 60%, 70%, ${opacity * 0.5})`);
                    gradient.addColorStop(1, `hsla(${cloud.hue}, 50%, 60%, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, particle.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        };
        
        // Draw plant
        const drawPlant = (plant) => {
            const progress = plant.age / plant.maxAge;
            const growthScale = progress < 0.33 ? progress / 0.33 : 1;
            
            if (growthScale <= 0) return;
            
            ctx.save();
            ctx.translate(plant.x, plant.y);
            
            const drawBranch = (x, y, length, angle, depth, thickness) => {
                if (depth === 0 || length < 1) return;
                
                const endX = x + Math.cos(angle) * length * growthScale;
                const endY = y + Math.sin(angle) * length * growthScale;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = `hsl(${plant.hue}, 60%, ${30 + depth * 10}%)`;
                ctx.lineWidth = thickness;
                ctx.stroke();
                
                if (depth <= 2 && growthScale > 0.7) {
                    ctx.fillStyle = `hsla(${plant.hue + 20}, 70%, 50%, ${0.6 * growthScale})`;
                    ctx.beginPath();
                    ctx.ellipse(endX, endY, thickness * 1.2, thickness * 1.8, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                const numBranches = depth === plant.branches ? 2 : 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < numBranches; i++) {
                    const branchAngle = angle + (Math.random() - 0.5) * 0.6;
                    drawBranch(
                        endX,
                        endY,
                        length * (0.65 + Math.random() * 0.15),
                        branchAngle,
                        depth - 1,
                        thickness * 0.75
                    );
                }
            };
            
            drawBranch(0, 0, plant.height, -Math.PI / 2, plant.branches, 1.5);
            
            ctx.restore();
        };
        
        // Draw person
        const drawPerson = (x, y, scale, walkPhase) => {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            
            const legSwing = Math.sin(walkPhase) * 8;
            const armSwing = Math.sin(walkPhase + Math.PI) * 6;
            const bobbing = Math.abs(Math.sin(walkPhase * 2)) * 2;
            
            const bodyY = -bobbing;
            
            ctx.fillStyle = '#2a2a4a';
            ctx.beginPath();
            ctx.arc(0, bodyY - 20, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(0, bodyY - 14);
            ctx.lineTo(0, bodyY + 5);
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, bodyY - 10);
            ctx.lineTo(-3 + armSwing * 0.3, bodyY + armSwing * 0.5);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, bodyY - 10);
            ctx.lineTo(3 - armSwing * 0.3, bodyY - armSwing * 0.5);
            ctx.stroke();
            
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(0, bodyY + 5);
            ctx.lineTo(-2 + legSwing * 0.4, bodyY + 15 + Math.abs(legSwing) * 0.3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, bodyY + 5);
            ctx.lineTo(2 - legSwing * 0.4, bodyY + 15 + Math.abs(-legSwing) * 0.3);
            ctx.stroke();
            
            ctx.restore();
        };
        
        // Animation loop
        function animate() {
            timeRef += 0.002;
            walkCycle += 0.08;
            
            const dayTime = (Date.now() / 8000) % 1;
            
            let skyColors, hillColors;
            
            if (dayTime < 0.25) {
                const t = dayTime / 0.25;
                skyColors = {
                    top: interpolateColor('#1a1a2e', '#0a0a1e', t),
                    mid1: interpolateColor('#16213e', '#0f1530', t),
                    mid2: interpolateColor('#533483', '#1a1a3a', t),
                    bottom: interpolateColor('#e94560', '#2a2a5a', t)
                };
                hillColors = [
                    interpolateColor('#1f1f3d', '#121228', t),
                    interpolateColor('#2d2d5a', '#1a1a35', t),
                    interpolateColor('#3d3d6b', '#222240', t),
                    interpolateColor('#4d4d7c', '#2a2a4b', t),
                    interpolateColor('#5d5d8d', '#323258', t)
                ];
            } else if (dayTime < 0.5) {
                const t = (dayTime - 0.25) / 0.25;
                skyColors = {
                    top: interpolateColor('#0a0a1e', '#ff9a56', t),
                    mid1: interpolateColor('#0f1530', '#ffa07a', t),
                    mid2: interpolateColor('#1a1a3a', '#ffb88c', t),
                    bottom: interpolateColor('#2a2a5a', '#ffd4a3', t)
                };
                hillColors = [
                    interpolateColor('#121228', '#4a3a5a', t),
                    interpolateColor('#1a1a35', '#5a4a6a', t),
                    interpolateColor('#222240', '#6a5a7a', t),
                    interpolateColor('#2a2a4b', '#7a6a8a', t),
                    interpolateColor('#323258', '#8a7a9a', t)
                ];
            } else if (dayTime < 0.75) {
                const t = (dayTime - 0.5) / 0.25;
                skyColors = {
                    top: interpolateColor('#ff9a56', '#87ceeb', t),
                    mid1: interpolateColor('#ffa07a', '#a0d8f0', t),
                    mid2: interpolateColor('#ffb88c', '#b8e2f5', t),
                    bottom: interpolateColor('#ffd4a3', '#d0ecf8', t)
                };
                hillColors = [
                    interpolateColor('#4a3a5a', '#5a7a5a', t),
                    interpolateColor('#5a4a6a', '#6a8a6a', t),
                    interpolateColor('#6a5a7a', '#7a9a7a', t),
                    interpolateColor('#7a6a8a', '#8aaa8a', t),
                    interpolateColor('#8a7a9a', '#9aba9a', t)
                ];
            } else {
                const t = (dayTime - 0.75) / 0.25;
                skyColors = {
                    top: interpolateColor('#87ceeb', '#1a1a2e', t),
                    mid1: interpolateColor('#a0d8f0', '#16213e', t),
                    mid2: interpolateColor('#b8e2f5', '#533483', t),
                    bottom: interpolateColor('#d0ecf8', '#e94560', t)
                };
                hillColors = [
                    interpolateColor('#5a7a5a', '#1f1f3d', t),
                    interpolateColor('#6a8a6a', '#2d2d5a', t),
                    interpolateColor('#7a9a7a', '#3d3d6b', t),
                    interpolateColor('#8aaa8a', '#4d4d7c', t),
                    interpolateColor('#9aba9a', '#5d5d8d', t)
                ];
            }
            
            if (Math.random() < 0.02 && blossoms.length < 12) {
                blossoms.push(createBlossom());
            }
            
            blossoms = blossoms.filter(b => {
                b.age++;
                b.rotation += b.rotationSpeed;
                return b.age < b.maxAge;
            });
            
            if (Math.random() < 0.015 && mistClouds.length < 6) {
                mistClouds.push(createMistCloud());
            }
            
            mistClouds = mistClouds.filter(cloud => {
                cloud.x += cloud.speed;
                return cloud.x < width + 100;
            });
            
            if (Math.random() < 0.03 && plants.length < 12) {
                plants.push(createPlant());
            }
            
            plants = plants.filter(plant => {
                plant.age++;
                plant.x -= plant.speed;
                return plant.x > -50;
            });
            
            const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.6);
            skyGradient.addColorStop(0, skyColors.top);
            skyGradient.addColorStop(0.3, skyColors.mid1);
            skyGradient.addColorStop(0.6, skyColors.mid2);
            skyGradient.addColorStop(1, skyColors.bottom);
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, height);
            
            const layers = [
                { y: 0.7, scale: 0.003, color: hillColors[0], amplitude: 80 },
                { y: 0.75, scale: 0.004, color: hillColors[1], amplitude: 70 },
                { y: 0.78, scale: 0.005, color: hillColors[2], amplitude: 60 },
                { y: 0.82, scale: 0.006, color: hillColors[3], amplitude: 50 },
                { y: 0.86, scale: 0.008, color: hillColors[4], amplitude: 40 }
            ];
            
            layers.forEach((layer, idx) => {
                ctx.beginPath();
                ctx.moveTo(0, height);
                
                for (let x = 0; x <= width; x += 2) {
                    const n = noise(
                        x * layer.scale + timeRef * (5 - idx) * 0.5,
                        idx * 10 + timeRef * 2,
                        4
                    );
                    const y = height * layer.y - n * layer.amplitude;
                    
                    if (x === 0) {
                        ctx.lineTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.lineTo(width, height);
                ctx.closePath();
                ctx.fillStyle = layer.color;
                ctx.fill();
            });
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
            for (let i = 0; i < 50; i++) {
                const x = (i * 137.5 + timeRef * 20) % width;
                const n = noise(i * 0.1, timeRef * 0.5);
                const y = height * 0.5 + n * height * 0.3;
                const size = 2 + n * 3;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            mistClouds.forEach(cloud => {
                drawMistCloud(cloud);
            });
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 100; i++) {
                const x = (i * 73.5) % width;
                const y = (i * 47.3) % (height * 0.5);
                const twinkle = (noise(i, timeRef * 2) + 1) * 0.5;
                if (twinkle > 0.7) {
                    ctx.beginPath();
                    ctx.arc(x, y, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            blossoms.forEach(blossom => {
                drawBlossom(blossom);
            });
            
            const groundLevel = height * 0.88;
            drawPerson(width * 0.4, groundLevel, 1.2, walkCycle);
            drawPerson(width * 0.435, groundLevel, 0.7, walkCycle + 0.5);
            
            plants.forEach(plant => {
                drawPlant(plant);
            });
            
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>